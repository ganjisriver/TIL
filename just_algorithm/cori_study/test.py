T, W = map(int, input().split())
dp = [[0]*(W+1) for _ in range(T+1)]
index_jadu = [0] # 0을 넣는 것은 초기값 및 인덱스 채우기 용이라 의미 딱히 없음.
for i in range(T): # 초당 자두가 떨어지는 리스트를 index_jadu로 만들어줌
    index_jadu.append(int(input()))

# i는 현재 시간(초)를 의미한다.
for i in range(1, T+1):
    #j는 자리를 바꾼 회수를 의미한다.
    for j in range(W+1):
        # j가 0이라는 의미는 자리를 바꾸지 않았다는 의미이다.
        # 따라서, 자두가 떨어지는 위치가 초기값인 1이고, 자리를 바꾸지 않았을 때, +1씩 추가하게 된다.
        # 자두가 떨어지는 위치가 2이면 자두를 먹지 못하기 때문에, 이전과 같다.
        if j == 0:
            if index_jadu[i] == 1:
                dp[i][0] = dp[i-1][0] + 1
            else:
                dp[i][0] = dp[i-1][0]
        # 이 아래는 사람이 이동을 했다는 의미다. 그렇기 때문에, j, 즉 움직인 회수를 통해서 사람의 위치를 파악할 수 있다.
        else:
            # index_jadu[i] == 1은 자두가 떨어지는 위치가 1이라는 의미이고, j % 2 == 0은 이동한 회수가 짝수번이기 때문에, 1번 위치에 있다는 의미다.
            # index_jadu[i] == 2는 자두가 떨어지는 위치가 2라는 의미이고, j % 2 == 1은 이동한 회수가 홀수번이기 때문에, 2번 위치에 있다는 의미다.
            # 두 가지 경우 모두 자두를 먹을 수 있는 위치에 있다는 공통점이 있다.
            if (index_jadu[i] == 1 and j % 2 == 0) or (index_jadu[i] == 2 and j % 2 == 1):
                # i-1은 현재 시간에서 1초 전의 시간을 의미한다. 즉, 이동을 한번만 할 수 있다는 뜻이다.
                # 이동을 한 번만 할 수 있기 때문에, 현재 이동을 한 것과 안한 것 중 더 높은 값을 비교하고, +1을 해주면 된다.
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-1]) + 1
            # 위에는 자두를 먹을 수 있는 경우였지만, 아래는 자두를 먹을 수 없는 위치에 있다는 특징이 있다.
            # 아래의 경우는 먹지 않고 거르는 게 나을 수 있는 상황이 있기 때문에, 그렇게 저장을 한다.
            else:
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-1])

# 마지막 초에서 가장 큰 값을 고르면 최대치를 고를 수 있다.
print(max(dp[-1]))
