# 프로젝트 회고(2)

이 글은 이전 글인 [프로젝트 회고(1)](https://ganjisriver.tistory.com/5)에 이어서 작성하는 글입니다. 이전 글에서는 내가 했던 프로젝트의 기획과정을 담았다면, 지금 쓰는 글에서는 제가 이번 프로젝트를 통해 배운 것, 아쉬웠던 점, 느낀 점 등을 정리하고 작성합니다.

## 배운 점 및 경험, 느낀점 정리

-----

이번 프로젝트에서 배운 것들이 정말 많다. 배운 것들에 대한 키워드와 이에 대해 제가 겪었던 상황과 감정을 서술하고, 키워드 별로 제가 공부했던 것들을 추가로 포스팅할 예정입니다.

#### WebRTC

- **STUN 서버** / **TURN 서버** / **Media 서버**

- **Openvidu / Kurento**

- **소켓통신**

- **https / ssl 인증**

WEBRTC는 아직도 어렵다. 그렇기 때문에, 마지막에 RTC 부분을 완성하지 못했나 싶은 생각이 든다. 이 부분에서도 CS 공부를 하지 않았던 것에 대한 후회를 발생하게 했다. 

WEBRTC는 웹 브라우저에서 실시간 통신을 구현하게 하는 오픈소스 인데, 일반적으로, 비디오, 음성 등을 브라우저에서 구현할 수 있게 된다. 이 과정에서 STUN서버와 TURN서버라는 개념이 등장하게 되었다. 

STUN서버는 네트워크 주소 변환 뒤에 있는 클라이언트의 공인 IP주소와 포트 번호를 알아내는데 사용된다. 이를 통해, 클라이언트와 중계 서버 사이에서 동작함으로써, 클라이언트가 중계 서버를 통해 대상 클라이언트에 연결할 수 있도록 해준다. 

TURN서버는 중계 서버로 작동하고, 서로의 연결이 실패하게 되면, 클라이언트 간 데이터를 모두 전달하고, 방화벽 연결이 차단되는 경우에도 사용된다.

**이해가 아직도 되지 않는다.** NAT나 방화벽 등 네트워크에 대한 개념이 부족하여 서버들에 대한 설명을 들어도 이해가 되지 않았다. 

결과적으로는 기존 WEBRTC가 직접적으로 연결하는 것에 실패했을 때,  중계 서버를 만들어서 우회적으로 연결해주는 정도로 이해하고 넘어갔다.

이에 대한 라이브러리로 Openvidu와 Kurento가 있는데, 굉장히 쉽게 설치 된다. 이 라이브러리들을 공부하면서 든 생각은 구체적인 사용법이 나와있는 블로그, 포스팅이 많지 않고, 라이브러리가 제공하는 객체나 메소드를 이해하지 못했다. 그러던 중 RTC 공부하던 다른 교육생이 공식문서를 보라고 했는데, **공식문서**에 아주 상세하게 많이 나와 있었다. 

이를 통해, 라이브러리는 공식문서가 최고라는 생각이 들었다. 상세한 설명과 해당 객체가 어떤 역할을 하는지, 파라미터는 무엇을 받아야 하는지, 예시 코드와 함께 아주 상세하게 설명되어 있었다.

아쉬운점:

RTC를 담당했던 프론트와 백엔드 담당분이 라이브러리를 사용하지 않고, 노마드코더님의 RTC를 활용한 Zoom 클론 코딩 강의를 들으면서 RTC 관련한 코드를 짰다. 오픈비두라는 대체제가 있었다는 점을 너무 늦게 알았고, 이미 RTC를 구현하는 것에 리소스를 상당히 투자했다.

이런 상황에서, 오픈비두라는 라이브러리를 학습하고, 그에 맞는 코드를 짜는 것에 추가 리소스를 투자하는 것은 프로젝트 마감 1주 정도 남은 시점에서 굉장히 부담이었고, STUN서버와 TURN서버에 대한 확실한 이해 없이, 진행했기 때문에, RTC 구현이 실패하지 않았나 생각이 든다.

STUN과 TURN서버가 내장된 오픈비두 라이브러리를 사용했어야 했나? STUN, TURN 서버가 구현이 제대로 되지 않았나? 아니면 https, ssl 인증이 문제였나? nginx 설정 파일안에 있는 설정이나 분기가 문제였나? 등 <- 가공하세요.

#### CI/CD

- **도커**

- **젠킨스**

- **빌드의 개념**

- **nginx**

- **리눅스와 가상환경**

#### 
