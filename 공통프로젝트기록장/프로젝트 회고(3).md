# 프로젝트 회고(3)

이 글은 이전 글인 [프로젝트 회고(1)](https://ganjisriver.tistory.com/5), [프로젝트 회고(2)](https://ganjisriver.tistory.com/6)에 이어서 작성하는 글입니다. 이전 글에서는 내가 했던 프로젝트의 기획과정을 담았다면, 지금 쓰는 글에서는 제가 이번 프로젝트를 통해 배운 것, 아쉬웠던 점, 느낀 점 등을 정리하고 작성합니다.



## 배운 점 및 경험, 느낀점 정리



지난 번 글에 이어서 추가적으로 내가 배운 지식과 감정 들을 기록한다.



### CI /CD + 기타 아키텍쳐

- **도커**

- **젠킨스**

- **빌드**

- **리눅스와 가상환경**

- **기타 (MSA, OAuth, 빌드의 개념, 아키텍쳐 구조 등)**



##### 처음 들었을 때의 CI/CD

CI/CD가 뭐야? 데브옵스 그런게 뭔데? 라는 생각을 했다. 그래서 나는 구글링을 했고, CI/CD를 검색하니 나온 것이 바로 Docker와 젠킨스였다. 연계로 docker와 젠킨스를 검색을 했더니, 그냥 프로젝트를 도커를 통해서 올리고, 젠킨스가 서버에 자동으로 올라가게끔 도와주는 기구라고 했다. 



SK planet에서 무료 유튜브 강의가 있는데, 그 영상 중 기억나는 건 젠킨스의 별명이 **노예**라는 것이었다. 뭐든지 다 대신 처리해 준다는 의미였다. **하지만, 노예가 되는 건 나였고...**



이 젠킨스를 사용해서, 자동 배포를 하는 것은 생각보다 복잡했다. 나는 깃랩에서 푸쉬만 하면, 내가 갖고있는 아마존이 운영하는 클라우드(EC2) 서버에 올라가는 것을 구현하려고 했다. 



- **웹훅 단계**



웹훅은 쉽게 말하자면,  깃랩에서 푸쉬하면 젠킨스가 인식할 수 있게 하는 것이 웹훅이다.

깃랩에서 푸쉬를 했다는 것을 EC2 서버 안에 있는 젠킨스 서버가 알고 있어야 했다. 그러기 위해서는, 깃랩에서 젠킨스 서버에 들어갈 수 있는 SSH 토큰이 필요했고, 젠킨스 서버에서도 깃랩의 레포지토리가 private 상태라면, 그걸 가져올 수 있는 권한이 필요했다. 

시작 할 때, SSH가 뭔지도 몰랐고, 웹훅이라는 것을 아는 것에도 시간이 걸렸다. 



- **빌드**

부끄럽게도, vue와 장고를 이용해서 작은 프로젝트를 만든 경험이 있음에도 불과하고, **빌드라는 것에 대해 잘 몰랐다.** 빌드는 쉽게 말하면, 우리들이 작성해 놓은 소스코드들을 응축해놓은 파일을 생성하는 것으로 볼 수 있겠다. 실제적인 cs적인 의미는 컴파일을 통해 기계어로 변환하는 어쩌구 등의 의미가 있지만, 여기서는 쉽게 말하도록 하겠다.



이러한 과정을 몰랐던 이유는 우리는 서버를 실행하는 키나 명령어들만 알아도 로컬에서 실행이 가능했기 때문이다. 장고는 python manage.py runserver, 스프링은 그냥 클릭 한번 등으로 서버를 킬 수 있으니, 굳이 알 필요가 없었다. 



로컬에서 서버를 실행해도, 빌드한 결과물을 통해 서버가 실행된다. 배포환경에서는 빌드라는 과정을 통해 결과물을 만들어내고, 실행시키는 것을 ide가 해주지 않고, 서버 안에서 명령어를 통해서 빌드하고 서버를 올리는 것을 해야했기 때문에, 빌드라는 개념을 알아야한다.



- **도커와 리눅스와 가상환경**

EC2서버는 우리 컴퓨터에 설치되어 있지않다. 외부에 있는 서버에 접속하기 위해서 나는 PUTTY라는 프로그램을 사용했다.



EC2서버에서 준 공개키를 이용해서, putty에 등록하고, 우리의 컴퓨터에서 외부의 서버에 접속할 수 있게 되었다. 



이전에, 젠킨스에서 웹훅을 통해, 깃에서 푸쉬가 발생하면, 젠킨스로 클론하여 가져오는 것 까지 완료를 했다. 

하지만, 나는 젠킨스가 어떻게, 깃 클론을 해오고, 여기서 빌드라는 것을 하는지 이해가 안됐다. 가상환경이라는 개념을 몰랐고, EC2라는 서버도, 일종의 컴퓨터라고 생각했어야 했는데, 낯선 터미널에서 어떻게 사용하는 지 몰라 당황스러웠다. 



우리가 배포환경에서 개발을 할 정도면 cs에 대한 지식은 몰라도 git bash에서 사용하는 cd라는 명령어는 알 것이다. 이것이  리눅스나 우분투라는 환경에서 사용하는 유닉스 계열의 명령어이고, 이러한 환경에서 사용하는 명령어를 익혀야 배포환경에서 명령어를 실행하거나, 원하는 동작들을 실행할 수 있는 것이다. 



이런 것들을 몰라서, 도커와 젠킨스를 이해하는데 시간이 걸렸다. 깃 클론을 한 나의 프로젝트 파일들은 젠킨스 도커 컨테이너내부에 있는 jenkinsworkspace라는 폴더 안에 들어가 있었고, 이곳에서 클론한 파일들을 도커를 통해서 새로운 가상환경, 서버를 만들어서 각자 독립적인 형태로 있게 할 수 있는 것이다.



젠킨스워크스페이스에 있는 내 프로젝트 파일들에서 sh라는 리눅스 명령어를 젠킨스에서 실행할 수 있게 하면서 **빌드**를 하고, **도커파일을 실행시켜 이미지화**를 한 후에,  도커 컨테이너를 만들어 주는 명령어를 적어주면 젠킨스 파이프라인에서의 자동화 완성이다.



하지만, 문제가 있었다. EC2서버에서 도커를 설치했지만, 젠킨스가 도커 컨테이너로 만들어져있고, 젠킨스가 돌아가고 있는 도커 컨테이너에서는 도커가 깔려있지 않았다. 도커 컨테이너 내부도 하나의 서버, 가상환경이기 때문에, 밖에서 도커가 깔려있다고 해서, 컨테이너 내부에 깔려있지는 않은 것이다. 또한, 젠킨스 컨테이너 안에서 컨테이너를 만들면, 서버 안에, 도커 컨테이너 안에 도커 컨테이너가 이중으로 들어가 있는 것이다.



이러한 문제를 해결하기 위해서는 DID(Docker in Docker) 라는 방식을 사용하는 것이었다. 도커 환경이 설치되어있는 EC2서버에서, 도커 컨테이너를 만들 때, 볼륨이라는 것을 설정할 수 있다. 도커 환경이 깔려있는 서버와 도커 컨테이너 간의 특정 폴더를 공유할 수 있는 것이다. 도커환경에 있는 EC2서버의  /var/run/docker.sock 파일 경로에 있다. 즉 도커 컨테이너를 만드는 명령어인 docker run명령어를 칠 때,  "-v /var/run/docker.sock:/var/run/docker.sock"" 을 넣어주면 젠킨스 도커 컨테이너에서 컨테이너를 만들어도 호스트와 공유가 되는 것이다. 



그렇게 해서, 도커와 젠킨스를 활용한 자동배포를 완성했다.



- **기타**

그 외적으로 MSA 구조, OAuth, 아키텍쳐 설계에 대한 이해가 많이 생겼다.



**MSA**

기존에 우리가 하던 방식은 모놀리식 방식으로 한 프로젝트, 서버 안에서 모든 기능을 넣는 방식이라면, MSA구조는 그 이름(MicroService Achitecture)답게 서비스 단위로 프로젝트 및 서버를 생성하여 운영, 관리 하는 것이다.



**MSA를 선택한 이유**는 사실 "요즘 면접에서 MSA에 대해 묻는 곳들이 있다더라", "MSA환경에서 개발해본 사람들을 선호한다더라" 라는 말을 들어서 우리도 해보자 라는 마인드로, MSA 구조에 대한 이해 없이, 무작정 설계를 하기 시작한 것이다.



하지만, MSA 환경에서 개발하면서, 꽤 많은 변수들이 발생하였고, 새로운 기술들을 익혀야 했던 것인데, 그 중 하나가 apigateway, 넷플릭스 유레카 서버 등 웹서버에서 API요청을 받아서 각각의 마이크로서비스 서버로 전달해주는 네트워크 연결을 했어야 했다. 이 과정에서 단순히 서로 외부에서 3000번이나 8000번 포트로 연결하던 방식에서 내부 네트워크끼리 연결해야하는 방식을 구현해야 했는데, 네트워크를 따로 공부한 적이 없어서 굉장히 어려움을 겪었다. 



결국에는 도커 컨테이너끼리 내부 네트워크 브릿지를 만들어서 구현하긴 했지만, 제대로 된 이해가 부족한 상태로 억지로 구현한 느낌이었다. **CS 공부의 필요성**을 느낀 경험이었다. 추후에 네트워크 공부를 빡세게 해서 관련 포스팅을 무조건 할 것이다.



**OAuth 및 JWT 등**



추가로 OAuth라는 것을 처음 알았다. 이전에 로그인 관련으로 작업 했었을 때는 장고가 유저 정보를 알아서 제공해주는 모델이 있었고, 소셜 로그인을 해본적이 없었기 때문에, 공부를 해야 했다. 카카오나 네이버 등의 소셜 플랫폼에서 제공해주는 API를 연결하고, 이를 JWT토큰을 만드는 작업을 공부했다.



엑세스토큰, 리프레쉬토큰의 동작원리, JWT토큰을 만들고, 어디에 저장해야하는가에 대한 논의, 세션과 쿠키 이에 따른 CSRF, XSS 공격 등으로 인한 보안 취약성 등 여러가지를 공부했다. 



**아키텍쳐 설계**

이러한 공부와 함께, 배포서버에서 서버를 직접 내가 올리는 공부 및 경험을 하다보니, 아키텍쳐에 대한 이해가 생겼다. 프로젝트 초창기에서 컨설턴트님이 말씀하신, 인증서버를 따로 만들어서 권한에 따라 서비스 흐름을 달리하거나, 경로를 설정해라 라는 말이 이해가 안되었다. 프로젝트가 끝난 지금에는 인증서버를 올려서 어떻게 서비스의 흐름을 이끌어 갈 것인가에 대한 생각을 조금은 더 할 수 있을 것 같다.



- 추가로 해보고 싶은 것

프로젝트가 끝났지만, 바로 새로운 프로젝트를 시작하는 단계인 만큼, 해보고 싶은 것이 여러가지 있다. 네트워크에 대한 공부를 조금 더 함으로써, 확실하게 아키텍쳐 설계를 깔끔하게 해보고 싶다.



추가적으로 MSA구조에서 많이 사용하는 Ansible을 이용한 서버 관리 도구와 컨테이너 관리를 위한 쿠버네티스, 코드 품질 관리를 위한 rabbitmq, 서버 간의 메시지 브로커 kafka등 다양하게 써보고 싶은 것들이 많다.



막상 이전 프로젝트에서 vue를 이용한 프론트엔드 개발을 맛만 보고, 이번에는 스프링 개발에는 제대로 기여를 못했기 때문에, 스프링 개발을 많이 해보고 싶긴 하다.



배포환경에서의 개발 경험을 중요하게 본다지만, 막상 스프링 개발을 제대로 못해보면, 아쉽기 때문에, 스프링에 더 신경쓰고, 이후에 저런 툴을 추가적으로 도입해서 하는 개발환경을 만들어보고 싶다.



회고를 하면서 더 추가적으로 정리하고 싶었던 것도 많고, 내가 공부한 것에 대해 더 자세히 포스팅 해보고 싶지만, 우선은 노션과 깃에만 정리를 해두고, 포스팅은 이후에 제대로 빡세게 정리해서 올려볼 생각이다.



정말 좋은 사람들과 많은 발전을 한 프로젝트 경험이었고, 재미있게 한 경험이었다.












